üìÅ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞:

 - bot.py
 - config.py
 - keyboards.py
 - test.py
 - tree.py
 - handlers\generation.py
 - handlers\info.py
 - handlers\prompt.py
 - handlers\start.py
 - handlers\vectorize.py
 - handlers\__init__.py
 - services\logo_generator.py
 - services\__init__.py
 - utils\states.py
 - utils\user_roles.py
 - utils\user_state.py
 - utils\__init__.py

üìÑ –°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–æ–≤:


üîπ bot.py:
------------------------------------------------------------
import logging
import asyncio
from aiogram import Bot, Dispatcher
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import CommandStart, Command
from aiogram.fsm.storage.memory import MemoryStorage
from config import TELEGRAM_BOT_TOKEN
from handlers import start, info, prompt, generation, vectorize
from utils.user_state import get_user_state, STATE_GENERATE, STATE_VECTORIZE, STATE_MENU
from utils.user_roles import load_db

logging.basicConfig(level=logging.INFO)
logging.getLogger("aiogram.event").setLevel(logging.DEBUG)

defaults = DefaultBotProperties(parse_mode=ParseMode.HTML)
bot = Bot(token=TELEGRAM_BOT_TOKEN, default=defaults)
dp = Dispatcher(storage=MemoryStorage())

def is_generate_text(message):
    return (
        message.text and not message.text.startswith("/")
        and get_user_state(message.from_user.id) == STATE_GENERATE
    )

def is_vectorization_photo(message):
    return (
        message.photo
        and get_user_state(message.from_user.id) == STATE_VECTORIZE
    )

# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Ö–µ–Ω–¥–ª–µ—Ä–æ–≤
dp.message.register(start.start, CommandStart())
dp.message.register(start.setrole_command, Command(commands=["setrole"]))
dp.message.register(start.start, lambda m: m.text == "‚¨ÖÔ∏è –í –º–µ–Ω—é")
dp.message.register(info.info, lambda m: m.text == "‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è")
dp.message.register(prompt.prompt_for_idea, lambda m: m.text == "üé® –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–æ–≥–æ—Ç–∏–ø–∞")
dp.message.register(vectorize.ask_for_image, lambda m: m.text == "üñº –í–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏—è")
dp.message.register(vectorize.handle_vectorization_image, is_vectorization_photo)
dp.message.register(generation.handle_idea, is_generate_text)

@dp.message()
async def fallback_handler(message):
    state = get_user_state(message.from_user.id)
    if state == STATE_MENU:
        await message.answer("‚ùóÔ∏è–í—ã —Å–µ–π—á–∞—Å –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ.")
    elif state == STATE_GENERATE:
        await message.answer("‚ùóÔ∏è–û–∂–∏–¥–∞–µ—Ç—Å—è —Ç–µ–∫—Å—Ç–æ–≤–∞—è –∏–¥–µ—è –ª–æ–≥–æ—Ç–∏–ø–∞.")
    elif state == STATE_VECTORIZE:
        await message.answer("‚ùóÔ∏è–û–∂–∏–¥–∞–µ—Ç—Å—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (—Ñ–æ—Ç–æ) –¥–ª—è –≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.")
    else:
        await message.answer("‚ùì –ù–µ–ø–æ–Ω—è—Ç–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ. –ù–∞–∂–º–∏—Ç–µ '‚¨ÖÔ∏è –í –º–µ–Ω—é'.")

if __name__ == "__main__":
    load_db()
    asyncio.run(dp.start_polling(bot))


üîπ config.py:
------------------------------------------------------------
import os
from dotenv import load_dotenv

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ .env
load_dotenv()

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")

# –ü—Ä–∏–≤–æ–¥–∏–º –∫ –±—É–ª–µ–≤–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—é (true ‚Üí True, –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω–æ–µ ‚Üí False)
USE_PLACEHOLDER = os.getenv("USE_PLACEHOLDER", "false").strip().lower() == "true"

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")


üîπ keyboards.py:
------------------------------------------------------------
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

def get_main_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üé® –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–æ–≥–æ—Ç–∏–ø–∞")],
            [KeyboardButton(text="üñº –í–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏—è")],
            [KeyboardButton(text="‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è")],
        ],
        resize_keyboard=True
    )

def get_back_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="‚¨ÖÔ∏è –í –º–µ–Ω—é")],
        ],
        resize_keyboard=True
    )


üîπ test.py:
------------------------------------------------------------
import os
import re

TARGET_FILES = [
    "handlers/generation.py",
    "handlers/vectorize.py",
]

ANSWER_CALL_RE = re.compile(r'(await\s+message\.answer\(([^)]*))\)', re.DOTALL)
IMPORT_RE = re.compile(r'^from\s+keyboards\s+import\s+([^\n]+)', re.MULTILINE)

def ensure_import(code: str, func_name: str) -> str:
    """–î–æ–±–∞–≤–ª—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é –≤ —Å—Ç—Ä–æ–∫—É –∏–º–ø–æ—Ä—Ç–∞, –ª–∏–±–æ –≤—Å—Ç–∞–≤–ª—è–µ—Ç –Ω–æ–≤—ã–π –∏–º–ø–æ—Ä—Ç"""
    match = IMPORT_RE.search(code)
    if match:
        existing = match.group(1).replace(" ", "").split(",")
        if func_name not in existing:
            new_import = match.group(0).replace(match.group(1), match.group(1) + f", {func_name}")
            return code.replace(match.group(0), new_import)
        else:
            return code  # —É–∂–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ
    else:
        # –í—Å—Ç–∞–≤–∏–º –Ω–æ–≤—ã–π –∏–º–ø–æ—Ä—Ç —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –≤—Å–µ—Ö –∏–º–ø–æ—Ä—Ç–æ–≤
        lines = code.splitlines()
        for i, line in enumerate(lines):
            if line.strip() and not line.strip().startswith("#") and not line.strip().startswith("import") and not line.strip().startswith("from"):
                # –í—Å—Ç–∞–≤–∏–º –¥–æ –ø–µ—Ä–≤–æ–π –Ω–µ-–∏–º–ø–æ—Ä—Ç —Å—Ç—Ä–æ–∫–∏
                lines.insert(i, f"from keyboards import {func_name}")
                break
        return "\n".join(lines)

def process_file(file_path):
    with open(file_path, "r", encoding="utf-8") as f:
        code = f.read()

    modified = False
    new_code = code

    for match in ANSWER_CALL_RE.finditer(code):
        full_call = match.group(0)
        inner = match.group(2)

        if "reply_markup=" in inner:
            continue

        fixed_call = f"{match.group(1)}, reply_markup=get_back_keyboard())"
        new_code = new_code.replace(full_call, fixed_call)
        modified = True

    if modified:
        # –î–æ–±–∞–≤–∏–º –∏–º–ø–æ—Ä—Ç, –µ—Å–ª–∏ –Ω–∞–¥–æ
        new_code = ensure_import(new_code, "get_back_keyboard")

        with open(file_path, "w", encoding="utf-8") as f:
            f.write(new_code)
        print(f"‚úÖ –û–±–Ω–æ–≤–ª—ë–Ω —Ñ–∞–π–ª: {file_path}")
    else:
        print(f"‚ûñ –ë–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π: {file_path}")

if __name__ == "__main__":
    for path in TARGET_FILES:
        if os.path.exists(path):
            process_file(path)
        else:
            print(f"‚ùå –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {path}")


üîπ tree.py:
------------------------------------------------------------
import os

IGNORE_DIRS = {"__init__.py", "tests", "__pycache__", ".git", "venv", ".venv", "env", ".idea", ".mypy_cache", ".vscode"}
IGNORE_FILES = {".env"}

def list_files(base_path="."):
    summary = []

    for root, dirs, files in os.walk(base_path):
        # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–µ–Ω—É–∂–Ω—ã–µ –ø–∞–ø–∫–∏
        dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
        files = [f for f in files if f.endswith(".py") and f not in IGNORE_FILES]

        # –°—Ç—Ä–æ–∏–º "–æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å"
        rel_root = os.path.relpath(root, base_path)
        for f in files:
            path = os.path.join(rel_root, f) if rel_root != "." else f
            summary.append(path)

    return summary

def print_project_structure(base_path="."):
    print("üìÅ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞:\n")
    for path in list_files(base_path):
        print(f" - {path}")
    print("\nüìÑ –°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–æ–≤:\n")

    for path in list_files(base_path):
        print(f"\nüîπ {path}:\n{'-'*60}")
        with open(os.path.join(base_path, path), "r", encoding="utf-8") as f:
            print(f.read())

if __name__ == "__main__":
    import sys
    with open('tree.txt', "w", encoding="utf-8") as f:
        sys.stdout = f  # –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º print –≤ —Ñ–∞–π–ª
        print_project_structure()


üîπ handlers\generation.py:
------------------------------------------------------------
from aiogram import types
from aiogram.fsm.context import FSMContext
from utils.states import GenerationStates
from utils.user_state import single_user_lock, is_generating, set_generating
from services.logo_generator import generate_image
from aiogram.types import BufferedInputFile
import logging
from utils.user_roles import can_generate, increment_usage, get_usage, get_user_role, ROLE_LIMITS

from keyboards import get_back_keyboard
async def handle_idea(message: types.Message, state: FSMContext):
    state_now = await state.get_state()
    if state_now != GenerationStates.waiting_for_idea.state:
        return

    user_id = message.from_user.id

    if not message.text:
        await message.answer("‚ùóÔ∏è–û–∂–∏–¥–∞–µ—Ç—Å—è —Ç–µ–∫—Å—Ç —Å –∏–¥–µ–µ–π –ª–æ–≥–æ—Ç–∏–ø–∞.", reply_markup=get_back_keyboard())
        return

    if not can_generate(user_id):
        usage = get_usage(user_id)
        role = get_user_role(user_id)
        g_used = usage["generations"]
        g_total = ROLE_LIMITS[role]["generations"]

        await message.answer(
            f"‚ùå –í—ã –∏—Å—á–µ—Ä–ø–∞–ª–∏ –ª–∏–º–∏—Ç <b>–≥–µ–Ω–µ—Ä–∞—Ü–∏–π –ª–æ–≥–æ—Ç–∏–ø–æ–≤</b>.\n\n"
            f"üé® –ì–µ–Ω–µ—Ä–∞—Ü–∏–π: {g_used} / {g_total}\n"
            f"‚ÑπÔ∏è –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ª–∏–º–∏—Ç—ã –º–æ–∂–Ω–æ —á–µ—Ä–µ–∑ '‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è'"
        , reply_markup=get_back_keyboard())
        return

    if is_generating(user_id):
        await message.answer("‚è≥ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ª–æ–≥–æ—Ç–∏–ø–∞.", reply_markup=get_back_keyboard())
        return

    async with single_user_lock(user_id):
        set_generating(user_id, True)
        await message.answer("–ì–µ–Ω–µ—Ä–∏—Ä—É—é –ª–æ–≥–æ—Ç–∏–ø, –ø–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ...", reply_markup=get_back_keyboard())
        try:
            image = await generate_image(message.text)
            image.seek(0)
            input_file = BufferedInputFile(file=image.read(), filename="logo.png")
            await message.answer_photo(photo=input_file, caption="–í–æ—Ç –ª–æ–≥–æ—Ç–∏–ø –ø–æ —Ç–≤–æ–µ–π –∏–¥–µ–µ!")
            await message.answer("üí° –ü—Ä–∏—à–ª–∏ –µ—â—ë –∏–¥–µ—é –∏–ª–∏ –Ω–∞–∂–º–∏ '‚¨ÖÔ∏è –í –º–µ–Ω—é'.", reply_markup=get_back_keyboard())
            increment_usage(user_id, "generations")

            # –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—Å—Ç–∞–≤—à–µ–º—Å—è –ª–∏–º–∏—Ç–µ
            role = get_user_role(user_id)
            usage = get_usage(user_id)
            g_left = ROLE_LIMITS[role]["generations"] - usage["generations"]
            await message.answer(f"üìä –û—Å—Ç–∞–ª–æ—Å—å –≥–µ–Ω–µ—Ä–∞—Ü–∏–π: {g_left}", reply_markup=get_back_keyboard())

        except Exception as e:
            logging.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏")
            await message.answer(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}", reply_markup=get_back_keyboard())
        finally:
            set_generating(user_id, False)

üîπ handlers\info.py:
------------------------------------------------------------
from aiogram import types
from keyboards import get_main_keyboard
from utils.user_state import set_user_state, STATE_MENU
from utils.user_roles import get_user_role, get_usage, ROLE_LIMITS

async def info(message: types.Message):
    user_id = message.from_user.id
    set_user_state(user_id, STATE_MENU)

    role = get_user_role(user_id)
    usage = get_usage(user_id)
    limits = ROLE_LIMITS[role]

    g = usage["generations"]
    v = usage["vectorizations"]
    g_limit = "‚àû" if limits["generations"] == float("inf") else limits["generations"]
    v_limit = "‚àû" if limits["vectorizations"] == float("inf") else limits["vectorizations"]

    await message.answer(
        f"‚ÑπÔ∏è –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–æ–≥–æ—Ç–∏–ø–æ–≤ —á–µ—Ä–µ–∑ GPT-4o + DALL¬∑E 3.\n\n"
        f"üë§ –í–∞—à–∞ —Ä–æ–ª—å: <b>{role}</b>\n"
        f"üé® –ì–µ–Ω–µ—Ä–∞—Ü–∏–π: {g} / {g_limit}\n"
        f"üñº –í–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–π: {v} / {v_limit}",
        reply_markup=get_main_keyboard()
    )


üîπ handlers\prompt.py:
------------------------------------------------------------
from aiogram import types
from aiogram.fsm.context import FSMContext
from keyboards import get_back_keyboard
from utils.user_state import set_user_state, STATE_GENERATE
from utils.states import GenerationStates  # ‚Üê –ù–µ –∑–∞–±—É–¥—å –∏–º–ø–æ—Ä—Ç

async def prompt_for_idea(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    set_user_state(user_id, STATE_GENERATE)
    await state.set_state(GenerationStates.waiting_for_idea)  # ‚Üê –í–ê–ñ–ù–û: —É—Å—Ç–∞–Ω–æ–≤–∏–º FSM-—Å–æ—Å—Ç–æ—è–Ω–∏–µ
    await message.answer(
        "‚úçÔ∏è –û—Ç–ø—Ä–∞–≤—å –∏–¥–µ—é –ª–æ–≥–æ—Ç–∏–ø–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: '–ª–æ–≥–æ—Ç–∏–ø –¥–ª—è –∫–æ—Ñ–µ–π–Ω–∏ –≤ –º–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω–æ–º —Å—Ç–∏–ª–µ')",
        reply_markup=get_back_keyboard()
    )


üîπ handlers\start.py:
------------------------------------------------------------
from aiogram import types
from keyboards import get_main_keyboard
from utils.user_state import set_user_state, STATE_MENU
from utils.user_roles import set_user_role, get_user_role, ROLE_LIMITS

ROLE_ORDER = ["user_free", "user_basic", "user_pro", "admin"]
SETROLE_PASSWORD = "qweqweqwe"

async def start(message: types.Message):
    user_id = message.from_user.id
    set_user_state(user_id, STATE_MENU)
    await message.answer(
        "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –ø–æ–º–æ–≥—É —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ª–æ–≥–æ—Ç–∏–ø. –í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=get_main_keyboard()
    )

async def setrole_command(message: types.Message):
    user_id = message.from_user.id
    parts = message.text.strip().split()

    if len(parts) != 4 or parts[0] != "/setrole" or parts[1] != "me":
        await message.answer(
            "‚ùì –§–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã:\n"
            "<code>/setrole me –ü–ê–†–û–õ–¨ user_basic</code>\n"
            "<code>/setrole me –ü–ê–†–û–õ–¨ up</code>\n"
            "<code>/setrole me –ü–ê–†–û–õ–¨ down</code>",
            reply_markup=get_main_keyboard()
        )
        return

    _, _, password, action = parts

    if password != SETROLE_PASSWORD:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å.", reply_markup=get_main_keyboard())
        return

    current_role = get_user_role(user_id)
    current_index = ROLE_ORDER.index(current_role)

    if action == "up":
        new_index = min(current_index + 1, len(ROLE_ORDER) - 1)
        new_role = ROLE_ORDER[new_index]
    elif action == "down":
        new_index = max(current_index - 1, 0)
        new_role = ROLE_ORDER[new_index]
    elif action in ROLE_ORDER:
        new_role = action
    else:
        await message.answer(
            "‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è —Ä–æ–ª—å. –î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: user_free, user_basic, user_pro, admin, up, down.",
            reply_markup=get_main_keyboard()
        )
        return

    set_user_role(user_id, new_role)
    await message.answer(
        f"‚úÖ –í–∞—à–∞ —Ä–æ–ª—å –æ–±–Ω–æ–≤–ª–µ–Ω–∞: <b>{new_role}</b>\n"
        f"üîÅ –õ–∏–º–∏—Ç—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –∏ –≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–π –±—ã–ª–∏ –æ–±–Ω—É–ª–µ–Ω—ã.",
        reply_markup=get_main_keyboard()
    )


üîπ handlers\vectorize.py:
------------------------------------------------------------
from aiogram import types
from aiogram.types import BufferedInputFile
from keyboards import get_back_keyboard
from utils.user_state import single_user_lock, is_generating, set_generating, set_user_state, STATE_VECTORIZE
import logging
import os
import requests
from dotenv import load_dotenv
from utils.user_roles import can_vectorize, increment_usage, get_usage, get_user_role, ROLE_LIMITS

load_dotenv()

VECTORIZE_USER = os.getenv("VECTORIZE_USER")
VECTORIZE_PASS = os.getenv("VECTORIZE_PASS")

async def ask_for_image(message: types.Message):
    user_id = message.from_user.id
    role = get_user_role(user_id)
    if ROLE_LIMITS[role]["vectorizations"] == 0:
        await message.answer("‚ùå –í –≤–∞—à–µ–π —Ä–æ–ª–∏ –≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –û–±–Ω–æ–≤–∏—Ç–µ —Ä–æ–ª—å.", reply_markup=get_back_keyboard())
        return
    set_user_state(user_id, STATE_VECTORIZE)
    await message.answer("üì§ –ü—Ä–∏—à–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.", reply_markup=get_back_keyboard())

async def handle_vectorization_image(message: types.Message):
    user_id = message.from_user.id

    if not can_vectorize(user_id):
        usage = get_usage(user_id)
        role = get_user_role(user_id)
        v_used = usage["vectorizations"]
        v_total = ROLE_LIMITS[role]["vectorizations"]

        await message.answer(
            f"‚ùå –í—ã –∏—Å—á–µ—Ä–ø–∞–ª–∏ –ª–∏–º–∏—Ç <b>–≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–π</b> –¥–ª—è –≤–∞—à–µ–π —Ä–æ–ª–∏.\n\n"
            f"üñº –í–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–π: {v_used} / {v_total}\n"
            f"‚ÑπÔ∏è –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ª–∏–º–∏—Ç—ã –º–æ–∂–Ω–æ —á–µ—Ä–µ–∑ '‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è'"
        , reply_markup=get_back_keyboard())
        return

    if is_generating(user_id):
        await message.answer("‚è≥ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.", reply_markup=get_back_keyboard())
        return

    async with single_user_lock(user_id):
        set_generating(user_id, True)
        try:
            photo = message.photo[-1]
            file = await message.bot.get_file(photo.file_id)
            downloaded_file = await message.bot.download_file(file.file_path)

            temp_path = f"temp_{user_id}.jpg"
            with open(temp_path, "wb") as f:
                f.write(downloaded_file.read())

            await message.answer("üîÑ –í–µ–∫—Ç–æ—Ä–∏–∑—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –ø–æ–¥–æ–∂–¥–∏—Ç–µ...", reply_markup=get_back_keyboard())

            with open(temp_path, "rb") as img:
                response = requests.post(
                    'https://ru.vectorizer.ai/api/v1/vectorize',
                    files={'image': img},
                    data={'mode': 'test'},
                    auth=(VECTORIZE_USER, VECTORIZE_PASS)
                )

            os.remove(temp_path)

            if response.status_code == 200:
                svg_path = f"vectorized_{user_id}.svg"
                with open(svg_path, "wb") as f:
                    f.write(response.content)

                with open(svg_path, "rb") as f:
                    svg_file = BufferedInputFile(file=f.read(), filename="vectorized.svg")
                    await message.answer_document(document=svg_file, caption="‚úÖ –í–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
                os.remove(svg_path)
                increment_usage(user_id, "vectorizations")

                # –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—Å—Ç–∞–≤—à–µ–º—Å—è –ª–∏–º–∏—Ç–µ
                role = get_user_role(user_id)
                usage = get_usage(user_id)
                v_left = ROLE_LIMITS[role]["vectorizations"] - usage["vectorizations"]
                await message.answer(f"üìä –û—Å—Ç–∞–ª–æ—Å—å –≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–π: {v_left}", reply_markup=get_back_keyboard())

            else:
                await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: {response.status_code}\n{response.text}", reply_markup=get_back_keyboard())

        except Exception as e:
            logging.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏")
            await message.answer(f"‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}", reply_markup=get_back_keyboard())
        finally:
            set_generating(user_id, False)


üîπ handlers\__init__.py:
------------------------------------------------------------


üîπ services\logo_generator.py:
------------------------------------------------------------
import requests
from io import BytesIO
import asyncio
from config import USE_PLACEHOLDER, OPENAI_API_KEY

async def generate_image(prompt: str) -> BytesIO:
    if USE_PLACEHOLDER:
        # await asyncio.sleep(0.)
        url = "https://placehold.co/1024x1024/png?text=Logo"
        response = requests.get(url)
        response.raise_for_status()
        return BytesIO(response.content)

    from openai import OpenAI
    client = OpenAI(api_key=OPENAI_API_KEY)

    chat = client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": "–¢—ã —Å–æ–∑–¥–∞–µ—à—å –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ª–æ–≥–æ—Ç–∏–ø–∞ —á–µ—Ä–µ–∑ DALL¬∑E 3."},
            {"role": "user", "content": prompt}
        ]
    )

    prompt_dalle = chat.choices[0].message.content.strip()

    image_response = client.images.generate(
        model="dall-e-3",
        prompt=prompt_dalle,
        n=1,
        size="1024x1024",
        quality="standard",
        style="vivid",
    )

    image_url = image_response.data[0].url
    img_data = requests.get(image_url)
    img_data.raise_for_status()

    return BytesIO(img_data.content)


üîπ services\__init__.py:
------------------------------------------------------------


üîπ utils\states.py:
------------------------------------------------------------
from aiogram.fsm.state import StatesGroup, State

class GenerationStates(StatesGroup):
    waiting_for_idea = State()


üîπ utils\user_roles.py:
------------------------------------------------------------
# utils/user_roles.py

import json
import os
from threading import Lock

DB_PATH = "limits_db.json"
db_lock = Lock()

ROLE_LIMITS = {
    "user_free": {"generations": 5, "vectorizations": 0},
    "user_basic": {"generations": 10, "vectorizations": 1},
    "user_pro": {"generations": 25, "vectorizations": 3},
    "admin": {"generations": float("inf"), "vectorizations": float("inf")},
}

user_data = {}

def load_db():
    global user_data
    if os.path.exists(DB_PATH):
        with db_lock:
            with open(DB_PATH, "r", encoding="utf-8") as f:
                user_data = json.load(f)
    else:
        user_data = {}

def save_db():
    with db_lock:
        with open(DB_PATH, "w", encoding="utf-8") as f:
            json.dump(user_data, f, ensure_ascii=False, indent=2)

def init_user(user_id: int):
    uid = str(user_id)
    if uid not in user_data:
        user_data[uid] = {
            "role": "user_free",
            "generations": 0,
            "vectorizations": 0,
        }
        save_db()

def get_user_role(user_id: int) -> str:
    init_user(user_id)
    return user_data[str(user_id)]["role"]

def set_user_role(user_id: int, role: str):
    init_user(user_id)
    user_data[str(user_id)]["role"] = role
    user_data[str(user_id)]["generations"] = 0  # –°–±—Ä–æ—Å –≥–µ–Ω–µ—Ä–∞—Ü–∏–π
    user_data[str(user_id)]["vectorizations"] = 0  # –°–±—Ä–æ—Å –≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–π
    save_db()

def get_usage(user_id: int):
    init_user(user_id)
    return user_data[str(user_id)]

def can_generate(user_id: int) -> bool:
    init_user(user_id)
    role = get_user_role(user_id)
    used = user_data[str(user_id)]["generations"]
    return used < ROLE_LIMITS[role]["generations"]

def can_vectorize(user_id: int) -> bool:
    init_user(user_id)
    role = get_user_role(user_id)
    used = user_data[str(user_id)]["vectorizations"]
    return used < ROLE_LIMITS[role]["vectorizations"]

def increment_usage(user_id: int, action: str):
    if action in ["generations", "vectorizations"]:
        init_user(user_id)
        user_data[str(user_id)][action] += 1
        save_db()


üîπ utils\user_state.py:
------------------------------------------------------------
import asyncio
from contextlib import asynccontextmanager

user_locks = {}
user_generation_flags = {}
user_states = {}

STATE_MENU = "menu"
STATE_GENERATE = "generate"
STATE_VECTORIZE = "vectorize"

@asynccontextmanager
async def single_user_lock(user_id: int):
    lock = user_locks.setdefault(user_id, asyncio.Lock())
    async with lock:
        yield

def is_generating(user_id):
    return user_generation_flags.get(user_id, False)

def set_generating(user_id, value: bool):
    user_generation_flags[user_id] = value

def set_user_state(user_id: int, state: str):
    user_states[user_id] = state

def get_user_state(user_id: int) -> str:
    return user_states.get(user_id, STATE_MENU)


üîπ utils\__init__.py:
------------------------------------------------------------

